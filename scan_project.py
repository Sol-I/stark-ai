import pyperclip
import re
from pathlib import Path
import argparse


class ProjectScanner:
    def __init__(self, root_dir='.'):
        self.root_dir = Path(root_dir).absolute()
        self.ignore_patterns = [
            '__pycache__', '.git', '.idea', '.vscode', 'venv', 'env',
            'node_modules', '.pytest_cache', '.mypy_cache', 'dist', 'build',
            '*.pyc', '*.pyo', '*.so', '*.dll', '*.exe'
        ]

    def should_ignore(self, path):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –Ω—É–∂–Ω–æ –ª–∏ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª/–ø–∞–ø–∫—É"""
        path_str = str(path)

        # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–∫—Ä—ã—Ç—ã–µ —Ñ–∞–π–ª—ã/–ø–∞–ø–∫–∏ (–Ω–∞—á–∏–Ω–∞—é—â–∏–µ—Å—è —Å .)
        if any(part.startswith('.') and part not in ['.', '..'] for part in path.parts):
            # –ù–æ –Ω–µ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º .env —Ñ–∞–π–ª—ã –∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∫–æ–Ω—Ñ–∏–≥–∏
            if path.name in ['.env', '.env.example', '.gitignore']:
                return False
            return True

        for pattern in self.ignore_patterns:
            if pattern.startswith('*'):
                if path_str.endswith(pattern[1:]):
                    return True
            elif pattern in path_str:
                return True
        return False

    def clean_python_code(self, content):
        """–û—á–∏—â–∞–µ—Ç Python –∫–æ–¥ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ LLM"""
        lines = content.split('\n')
        cleaned_lines = []

        for line in lines:
            stripped = line.rstrip()

            # –£–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –≤ –∫–æ–Ω—Ü–µ —Ñ–∞–π–ª–∞
            if not stripped and not cleaned_lines:
                continue

            # –£–¥–∞–ª—è–µ–º –æ–¥–Ω–æ—Å—Ç—Ä–æ—á–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ (–∫—Ä–æ–º–µ shebang)
            if stripped.startswith('#') and not stripped.startswith('#!'):
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –≤–∞–∂–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ (TODO, FIXME, etc.)
                if any(marker in stripped.upper() for marker in ['TODO', 'FIXME', 'HACK', 'NOTE', 'IMPORTANT']):
                    cleaned_lines.append(stripped)
                continue

            # –£–¥–∞–ª—è–µ–º –∏–º–ø–æ—Ä—Ç—ã (–æ–Ω–∏ –æ–±—ã—á–Ω–æ –Ω–µ –≤–∞–∂–Ω—ã –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –ª–æ–≥–∏–∫–∏)
            if re.match(r'^\s*(from|import)\s+\S', stripped):
                continue

            cleaned_lines.append(stripped)

        # –£–¥–∞–ª—è–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
        result_lines = []
        prev_empty = False
        for line in cleaned_lines:
            current_empty = not line.strip()
            if current_empty and prev_empty:
                continue
            result_lines.append(line)
            prev_empty = current_empty

        # –£–±–∏—Ä–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –≤ –∫–æ–Ω—Ü–µ
        while result_lines and not result_lines[-1].strip():
            result_lines.pop()

        return '\n'.join(result_lines)

    def clean_other_content(self, content, file_extension):
        """–û—á–∏—â–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤ —Ñ–∞–π–ª–æ–≤"""
        lines = content.split('\n')
        cleaned_lines = []

        for line in lines:
            stripped = line.rstrip()

            # –î–ª—è JSON, YAML, TOML - —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ –µ—Å—Ç—å, –Ω–æ —É–±–∏—Ä–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
            if file_extension in ['.json', '.yaml', '.yml', '.toml']:
                if stripped:
                    cleaned_lines.append(stripped)
            # –î–ª—è Markdown - –Ω–µ–º–Ω–æ–≥–æ –æ—á–∏—â–∞–µ–º
            elif file_extension == '.md':
                cleaned_lines.append(stripped)
            # –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö - —É–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
            else:
                cleaned_lines.append(stripped)

        # –£–±–∏—Ä–∞–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
        result_lines = []
        prev_empty = False
        for line in cleaned_lines:
            current_empty = not line.strip()
            if current_empty and prev_empty:
                continue
            result_lines.append(line)
            prev_empty = current_empty

        return '\n'.join(result_lines)

    def get_file_content(self, file_path):
        """–ß–∏—Ç–∞–µ—Ç –∏ –æ—á–∏—â–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞"""
        try:
            content = file_path.read_text(encoding='utf-8', errors='ignore')

            if file_path.suffix == '.py':
                return self.clean_python_code(content)
            else:
                return self.clean_other_content(content, file_path.suffix)

        except Exception as e:
            return f"[–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: {e}]"

    def scan_structure_markdown(self):
        """–†–µ–∂–∏–º 0: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ Markdown –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        output = ["# –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞\n"]

        def scan_directory(directory, level=0):
            try:
                items = sorted(directory.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower()))

                for item in items:
                    if self.should_ignore(item):
                        continue

                    indent = "  " * level
                    if item.is_dir():
                        output.append(f"{indent}- **üìÅ {item.name}/**")
                        scan_directory(item, level + 1)
                    else:
                        output.append(f"{indent}- üìÑ {item.name}")

            except PermissionError:
                output.append(f"{'  ' * level}- *[–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω]*")

        scan_directory(self.root_dir)
        return "\n".join(output)

    def scan_structure_context(self):
        """–†–µ–∂–∏–º 1: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ LLM"""
        output = ["PROJECT STRUCTURE:"]

        def scan_directory(directory, level=0):
            try:
                items = sorted(directory.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower()))

                for item in items:
                    if self.should_ignore(item):
                        continue

                    indent = "  " * level
                    if item.is_dir():
                        output.append(f"{indent}{item.name}/")
                        scan_directory(item, level + 1)
                    else:
                        output.append(f"{indent}{item.name}")

            except PermissionError:
                output.append(f"{'  ' * level}[Permission denied]")

        scan_directory(self.root_dir)
        return "\n".join(output)

    def scan_full_context(self):
        """–†–µ–∂–∏–º 2: –ü–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å —Å–æ–¥–µ—Ä–∂–∏–º—ã–º —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ LLM"""
        output = ["PROJECT ANALYSIS:"]

        # –°–Ω–∞—á–∞–ª–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
        structure = []
        file_paths = []

        def collect_structure(directory, level=0):
            try:
                items = sorted(directory.iterdir(), key=lambda x: (not x.is_dir(), x.name.lower()))

                for item in items:
                    if self.should_ignore(item):
                        continue

                    indent = "  " * level
                    if item.is_dir():
                        structure.append(f"{indent}{item.name}/")
                        collect_structure(item, level + 1)
                    else:
                        structure.append(f"{indent}{item.name}")
                        file_paths.append(item)

            except PermissionError:
                structure.append(f"{'  ' * level}[Permission denied]")

        collect_structure(self.root_dir)
        output.append("STRUCTURE:")
        output.extend(structure)
        output.append("\n" + "=" * 50 + "\n")

        # –ó–∞—Ç–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤–∞–∂–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        output.append("FILE CONTENTS:")

        # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —Ñ–∞–π–ª—ã —Å–Ω–∞—á–∞–ª–∞
        priority_files = []
        other_files = []

        for file_path in file_paths:
            if file_path.suffix in ['.py', '.md', '.txt', '.json', '.yaml', '.yml', '.toml']:
                priority_files.append(file_path)
            else:
                other_files.append(file_path)

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —Ñ–∞–π–ª—ã
        for file_path in priority_files:
            output.append(f"\n--- FILE: {file_path.relative_to(self.root_dir)} ---")
            content = self.get_file_content(file_path)
            if content.strip():
                output.append(content)
            else:
                output.append("[File is empty or contains only comments/imports]")

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ–±–æ–ª—å—à–∏–µ)
        for file_path in other_files:
            try:
                file_size = file_path.stat().st_size
                if file_size < 5000:  # –¢–æ–ª—å–∫–æ –º–∞–ª–µ–Ω—å–∫–∏–µ —Ñ–∞–π–ª—ã
                    output.append(f"\n--- FILE: {file_path.relative_to(self.root_dir)} ---")
                    content = self.get_file_content(file_path)
                    if content.strip():
                        output.append(content[:1000])  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä
            except:
                pass

        return "\n".join(output)

    def scan_project(self, type_output=None):
        """–û—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ—Ü–µ–¥—É—Ä–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è"""
        if type_output is None or type_output == 0:
            return self.scan_structure_markdown()
        elif type_output == 1:
            return self.scan_structure_context()
        elif type_output == 2:
            return self.scan_full_context()
        else:
            raise ValueError("type_output –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 0, 1 –∏–ª–∏ 2")


def main():
    """–ó–∞–ø—É—Å–∫ –∏–∑ PyCharm –∏–ª–∏ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏"""
    parser = argparse.ArgumentParser(description='–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø—Ä–æ–µ–∫—Ç–∞')
    parser.add_argument('--root', '-r', default='.', help='–ö–æ—Ä–Ω–µ–≤–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –ø—Ä–æ–µ–∫—Ç–∞')
    parser.add_argument('--type', '-t', type=int, choices=[0, 1, 2], default=0,
                        help='–¢–∏–ø –≤—ã–≤–æ–¥–∞: 0-Markdown, 1-–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è LLM, 2-–ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è LLM')
    parser.add_argument('--output', '-o', help='–§–∞–π–ª –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞')

    args = parser.parse_args()

    scanner = ProjectScanner(args.root)
    result = scanner.scan_project(args.type)

    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(result)
        print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤: {args.output}")
    else:
        print(result)


# –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —É–¥–æ–±–Ω–æ–≥–æ –∏–º–ø–æ—Ä—Ç–∞
def scan_project_structure(root_dir='.', type_output=0):
    """
    –°–∫–∞–Ω–∏—Ä—É–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø—Ä–æ–µ–∫—Ç–∞

    Args:
        root_dir (str): –ö–æ—Ä–Ω–µ–≤–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
        type_output (int): –¢–∏–ø –≤—ã–≤–æ–¥–∞ (0, 1, 2)

    Returns:
        str: –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞
    """
    scanner = ProjectScanner(root_dir)
    return scanner.scan_project(type_output)


def save_project_context(root_dir='.', output_file='project_context.txt', type_output=2):
    """
    –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞ –≤ —Ñ–∞–π–ª

    Args:
        root_dir (str): –ö–æ—Ä–Ω–µ–≤–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
        output_file (str): –§–∞–π–ª –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        type_output (int): –¢–∏–ø –≤—ã–≤–æ–¥–∞ (0, 1, 2)
    """
    scanner = ProjectScanner(root_dir)
    result = scanner.scan_project(type_output)

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(result)

    print(f"–ö–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤: {output_file}")
    print(f"–†–∞–∑–º–µ—Ä: {len(result)} —Å–∏–º–≤–æ–ª–æ–≤")


def extract_api_documentation(file_path):
    """
    API: –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏–∑ —Ñ–∞–π–ª–æ–≤ –ø—Ä–æ–µ–∫—Ç–∞
    –í—Ö–æ–¥: file_path (–ø—É—Ç—å –∫ —Ñ–∞–π–ª—É)
    –í—ã—Ö–æ–¥: str (–æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è)
    –õ–æ–≥–∏–∫–∞: –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç Python —Ñ–∞–π–ª—ã, –∏–∑–≤–ª–µ–∫–∞–µ—Ç –∫–ª–∞—Å—Å—ã –∏ —Ñ—É–Ω–∫—Ü–∏–∏ —Å –¥–æ–∫—Å—Ç—Ä–∏–Ω–≥–∞–º–∏
    """
    try:
        content = file_path.read_text(encoding='utf-8')

        # –ò—â–µ–º –∫–ª–∞—Å—Å—ã –∏ —Ñ—É–Ω–∫—Ü–∏–∏ —Å –¥–æ–∫—Å—Ç—Ä–∏–Ω–≥–∞–º–∏
        classes = re.findall(r'class (\w+).*?"""(.*?)"""', content, re.DOTALL)
        functions = re.findall(r'def (\w+)\(.*?"""(.*?)"""', content, re.DOTALL)

        docs = []
        if classes:
            docs.append(f"CLASSES in {file_path.name}:")
            for class_name, docstring in classes:
                docs.append(f"  {class_name}: {docstring.strip()[:100]}...")

        if functions:
            docs.append(f"FUNCTIONS in {file_path.name}:")
            for func_name, docstring in functions:
                docs.append(f"  {func_name}: {docstring.strip()[:100]}...")

        return "\n".join(docs) if docs else f"[No API docs in {file_path.name}]"

    except Exception as e:
        return f"[Error reading {file_path.name}: {e}]"


def scan_api_documentation(root_dir='.'):
    """
    API: –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞
    –í—Ö–æ–¥: root_dir (–∫–æ—Ä–Ω–µ–≤–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è)
    –í—ã—Ö–æ–¥: str (—Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –≤—Å–µ—Ö API)
    –õ–æ–≥–∏–∫–∞: –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏—Ç —Ñ–∞–π–ª—ã, –∏–∑–≤–ª–µ–∫–∞–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ LLM
    """
    scanner = ProjectScanner(root_dir)

    output = ["PROJECT API DOCUMENTATION:"]
    output.append("=" * 50)

    root_path = Path(root_dir)
    python_files = list(root_path.rglob('*.py'))

    for file_path in python_files:
        if scanner.should_ignore(file_path):
            continue

        api_docs = extract_api_documentation(file_path)
        if api_docs:
            output.append(f"\n--- {file_path.relative_to(root_path)} ---")
            output.append(api_docs)

    return "\n".join(output)

if __name__ == "__main__":
    print(scan_project_structure('.', 0))
    # project_structure = scan_project_structure('.', 1)
    # full_context = scan_project_structure('.', 2)
    api_context = scan_api_documentation()
    pyperclip.copy(api_context)

